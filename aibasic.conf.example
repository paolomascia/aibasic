[llm]
API_URL = https://api.openai.com/v1/chat/completions
API_TOKEN = <<YOUR TOKEN HERE>>
API_VERSION = 1
MODEL = gpt-4o-mini

[postgres]
# PostgreSQL connection settings
# Uncomment and configure these settings to use the postgres module
# HOST = localhost
# PORT = 5432
# DATABASE = mydb
# USER = postgres
# PASSWORD = secret
# MIN_CONNECTIONS = 1
# MAX_CONNECTIONS = 10

[mysql]
# MySQL/MariaDB connection settings
# Uncomment and configure these settings to use the mysql module
# HOST = localhost
# PORT = 3306
# DATABASE = mydb
# USER = root
# PASSWORD = secret
# MIN_CONNECTIONS = 1
# MAX_CONNECTIONS = 10
# CHARSET = utf8mb4

[rabbitmq]
# RabbitMQ message broker settings
# Uncomment and configure these settings to use the rabbitmq module
# HOST = localhost
# PORT = 5672
# VHOST = /
# USERNAME = guest
# PASSWORD = guest

# SSL/TLS settings (optional)
# USE_SSL = false
# SSL_VERIFY = true
# SSL_CA_CERT = /path/to/ca_cert.pem
# SSL_CLIENT_CERT = /path/to/client_cert.pem
# SSL_CLIENT_KEY = /path/to/client_key.pem

# Connection settings
# HEARTBEAT = 60
# BLOCKED_CONNECTION_TIMEOUT = 300
# CONNECTION_ATTEMPTS = 3
# RETRY_DELAY = 2

[kafka]
# Apache Kafka streaming platform settings
# Uncomment and configure these settings to use the kafka module
# BOOTSTRAP_SERVERS = localhost:9092

# Security Protocol: PLAINTEXT, SASL_PLAINTEXT, SASL_SSL, SSL
# SECURITY_PROTOCOL = PLAINTEXT

# SASL Settings (if using SASL_PLAINTEXT or SASL_SSL)
# SASL_MECHANISM = PLAIN
# SASL_USERNAME = user
# SASL_PASSWORD = password

# SSL/TLS Settings (if using SASL_SSL or SSL)
# SSL_CHECK_HOSTNAME = true
# SSL_VERIFY = true
# SSL_CA_CERT = /path/to/ca-cert.pem
# SSL_CLIENT_CERT = /path/to/client-cert.pem
# SSL_CLIENT_KEY = /path/to/client-key.pem

# Producer Settings
# PRODUCER_ACKS = all
# PRODUCER_COMPRESSION = gzip
# PRODUCER_MAX_REQUEST_SIZE = 1048576

# Consumer Settings
# CONSUMER_GROUP_ID = aibasic-consumer-group
# CONSUMER_AUTO_OFFSET_RESET = earliest
# CONSUMER_ENABLE_AUTO_COMMIT = true

[redis]
# Redis in-memory data store settings
# Uncomment and configure these settings to use the redis module
# HOST = localhost
# PORT = 6379
# DB = 0
# PASSWORD = secret

# SSL/TLS Settings (optional)
# USE_SSL = false
# SSL_VERIFY = true
# SSL_CA_CERT = /path/to/ca.pem
# SSL_CLIENT_CERT = /path/to/client-cert.pem
# SSL_CLIENT_KEY = /path/to/client-key.pem

# ACL Authentication (Redis 6+)
# USERNAME = default

# Connection Pool Settings
# MAX_CONNECTIONS = 50
# SOCKET_TIMEOUT = 5
# SOCKET_CONNECT_TIMEOUT = 5
# DECODE_RESPONSES = true

[opensearch]
# OpenSearch distributed search and analytics engine settings
# Uncomment and configure these settings to use the opensearch module
# HOST = localhost
# PORT = 9200
# USE_SSL = false
# VERIFY_CERTS = true

# Basic Authentication
# USERNAME = admin
# PASSWORD = admin

# AWS IAM Authentication (for AWS OpenSearch Service)
# USE_AWS_AUTH = false
# AWS_REGION = us-east-1

# SSL/TLS Settings (optional)
# CA_CERTS = /path/to/ca.pem
# CLIENT_CERT = /path/to/client-cert.pem
# CLIENT_KEY = /path/to/client-key.pem

# Connection Settings
# TIMEOUT = 30
# MAX_RETRIES = 3
# POOL_MAXSIZE = 10

[vault]
# HashiCorp Vault secrets management settings
# Uncomment and configure these settings to use the vault module
# URL = https://vault.example.com:8200
# VERIFY_SSL = true

# Token Authentication (simplest, recommended for dev)
# AUTH_METHOD = token
# TOKEN = s.xxxxxxxxxxxxxxxxxxxxxxxx

# AppRole Authentication (recommended for production apps)
# AUTH_METHOD = approle
# ROLE_ID = xxxxx-xxxx-xxxx-xxxx-xxxxx
# SECRET_ID = xxxxx-xxxx-xxxx-xxxx-xxxxx

# Kubernetes Authentication (for K8s deployments)
# AUTH_METHOD = kubernetes
# K8S_ROLE = my-role
# K8S_JWT_PATH = /var/run/secrets/kubernetes.io/serviceaccount/token

# AWS IAM Authentication
# AUTH_METHOD = aws
# AWS_ROLE = my-role

# LDAP Authentication (use login_ldap() method)
# AUTH_METHOD = ldap

# GitHub Authentication (use login_github() method)
# AUTH_METHOD = github

# Username/Password Authentication (use login_userpass() method)
# AUTH_METHOD = userpass

# TLS Certificate Authentication
# AUTH_METHOD = cert
# CLIENT_CERT = /path/to/client-cert.pem
# CLIENT_KEY = /path/to/client-key.pem

# SSL/TLS Settings (optional)
# CA_CERT = /path/to/ca.pem

# Vault Settings
# NAMESPACE = admin  # For Vault Enterprise
# MOUNT_POINT = secret  # KV secrets engine mount point
# KV_VERSION = 2  # KV engine version (1 or 2)

[cassandra]
# Apache Cassandra distributed NoSQL database settings
# Uncomment and configure these settings to use the cassandra module
# CONTACT_POINTS = localhost,node2.example.com,node3.example.com
# PORT = 9042
# KEYSPACE = my_keyspace

# Authentication
# USERNAME = cassandra
# PASSWORD = cassandra

# SSL/TLS Settings (optional)
# USE_SSL = false
# SSL_VERIFY = true
# SSL_CA_CERT = /path/to/ca.pem
# SSL_CLIENT_CERT = /path/to/client-cert.pem
# SSL_CLIENT_KEY = /path/to/client-key.pem

# Connection Settings
# CONSISTENCY_LEVEL = LOCAL_QUORUM  # ONE, QUORUM, ALL, LOCAL_QUORUM, etc.
# LOAD_BALANCING_POLICY = RoundRobinPolicy  # RoundRobinPolicy, DCAwareRoundRobinPolicy, TokenAwarePolicy
# PROTOCOL_VERSION = 4
# CONNECT_TIMEOUT = 10
# REQUEST_TIMEOUT = 30

[email]
# SMTP email sending settings
# Uncomment and configure these settings to use the email module
# SMTP_HOST = smtp.gmail.com  # Gmail SMTP server
# SMTP_PORT = 587  # 587 for TLS, 465 for SSL, 25 for plain
# USERNAME = your-email@gmail.com
# PASSWORD = your-app-password  # For Gmail, use App Password not regular password

# Encryption (choose one)
# USE_TLS = true  # STARTTLS encryption (recommended, port 587)
# USE_SSL = false  # SSL encryption (port 465)

# Sender Information
# FROM_EMAIL = your-email@gmail.com  # Default sender email
# FROM_NAME = My Application  # Default sender name

# Connection Settings
# TIMEOUT = 30  # Connection timeout in seconds

# Common SMTP Servers:
# Gmail: smtp.gmail.com:587 (TLS) - Requires App Password
# Outlook/Office365: smtp.office365.com:587 (TLS)
# Yahoo: smtp.mail.yahoo.com:587 (TLS)
# SendGrid: smtp.sendgrid.net:587 (TLS)
# Amazon SES: email-smtp.us-east-1.amazonaws.com:587 (TLS)

[mongodb]
# MongoDB document-oriented NoSQL database settings
# Uncomment and configure these settings to use the mongodb module

# Connection String (recommended - overrides individual parameters if set)
# CONNECTION_STRING = mongodb://username:password@localhost:27017/mydb?authSource=admin

# Or use individual parameters:
# HOST = localhost
# PORT = 27017
# DATABASE = mydb
# USERNAME = admin
# PASSWORD = secret

# Authentication Database (optional, defaults to admin)
# AUTH_SOURCE = admin

# SSL/TLS Settings (optional)
# TLS = false
# TLS_ALLOW_INVALID_CERTIFICATES = false  # Set to true for self-signed certs (dev only)
# TLS_CA_FILE = /path/to/ca.pem
# TLS_CERT_KEY_FILE = /path/to/client.pem

# Connection Pool Settings
# MAX_POOL_SIZE = 100
# MIN_POOL_SIZE = 0

# Timeout Settings (milliseconds)
# SERVER_SELECTION_TIMEOUT_MS = 30000
# CONNECT_TIMEOUT_MS = 20000
# SOCKET_TIMEOUT_MS = 20000

# Replica Set (optional)
# REPLICA_SET = rs0

# Read/Write Preferences
# READ_PREFERENCE = primary  # primary, primaryPreferred, secondary, secondaryPreferred, nearest
# W = 1  # Write concern: number of nodes that must acknowledge writes

[s3]
# S3/MinIO object storage settings
# Uncomment and configure these settings to use the s3 module

# AWS S3 Configuration
# ENDPOINT_URL = https://s3.amazonaws.com  # Omit for AWS S3 (auto-detected)
# AWS_ACCESS_KEY_ID = AKIAIOSFODNN7EXAMPLE
# AWS_SECRET_ACCESS_KEY = wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
# REGION = us-east-1

# MinIO Configuration (alternative to AWS S3)
# ENDPOINT_URL = http://localhost:9000
# AWS_ACCESS_KEY_ID = minioadmin
# AWS_SECRET_ACCESS_KEY = minioadmin
# REGION = us-east-1
# VERIFY_SSL = false  # Set to false for MinIO with self-signed certs

# DigitalOcean Spaces Configuration (alternative)
# ENDPOINT_URL = https://nyc3.digitaloceanspaces.com
# AWS_ACCESS_KEY_ID = your_spaces_key
# AWS_SECRET_ACCESS_KEY = your_spaces_secret
# REGION = nyc3

# Wasabi Configuration (alternative)
# ENDPOINT_URL = https://s3.wasabisys.com
# AWS_ACCESS_KEY_ID = your_wasabi_key
# AWS_SECRET_ACCESS_KEY = your_wasabi_secret
# REGION = us-east-1

# SSL/TLS Settings
# VERIFY_SSL = true  # Set to false for self-signed certificates (dev only)

# Optional Settings
# DEFAULT_BUCKET = my-default-bucket  # Default bucket for operations
# SIGNATURE_VERSION = s3v4  # Signature version (s3v4 recommended)
# MULTIPART_THRESHOLD = 8388608  # 8MB - files larger than this use multipart upload
# MULTIPART_CHUNKSIZE = 8388608  # 8MB - chunk size for multipart uploads

[restapi]
# REST API client settings
# Uncomment and configure these settings to use the restapi module

# Base URL for API (optional - can be specified per request)
# BASE_URL = https://api.example.com/v1

# Authentication Method: none, basic, bearer, apikey, oauth2
# AUTH_METHOD = none

# Bearer Token Authentication (for JWT, OAuth 2.0 access tokens)
# AUTH_METHOD = bearer
# BEARER_TOKEN = eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# Basic Authentication (username and password)
# AUTH_METHOD = basic
# USERNAME = your_username
# PASSWORD = your_password

# API Key Authentication (header-based or query parameter)
# AUTH_METHOD = apikey
# API_KEY = your_api_key_here
# API_KEY_HEADER = X-API-Key  # Header name for API key
# API_KEY_PARAM = api_key  # Or use query parameter instead of header

# OAuth 2.0 Client Credentials Flow
# AUTH_METHOD = oauth2
# OAUTH2_CLIENT_ID = your_client_id
# OAUTH2_CLIENT_SECRET = your_client_secret
# OAUTH2_TOKEN_URL = https://auth.example.com/oauth/token

# SSL/TLS Settings
# VERIFY_SSL = true  # Set to false for self-signed certificates (dev only)

# Request Settings
# TIMEOUT = 30  # Request timeout in seconds
# MAX_RETRIES = 3  # Maximum number of retries for failed requests
# RETRY_BACKOFF = 1.0  # Backoff factor for retries (exponential)

# Default Headers (JSON format)
# HEADERS = {"User-Agent": "AIBasic/1.0", "Accept": "application/json"}

# Proxy Settings (optional)
# HTTP_PROXY = http://proxy.example.com:8080
# HTTPS_PROXY = https://proxy.example.com:8080

# =============================================================================
# SSH Module Configuration
# =============================================================================
# [ssh]
# HOST = server.example.com
# PORT = 22
# USERNAME = admin

# Password Authentication
# PASSWORD = your_password_here

# Key-Based Authentication (recommended)
# KEY_FILE = /path/to/private_key  # e.g., ~/.ssh/id_rsa or ~/.ssh/id_ed25519
# KEY_PASSWORD = key_passphrase  # Only if the key is encrypted

# Host Key Verification
# VERIFY_HOST_KEY = false  # true (strict), false (ignore), or auto-add

# Connection Timeouts (seconds)
# TIMEOUT = 30  # Overall connection timeout
# BANNER_TIMEOUT = 15  # SSH banner read timeout
# AUTH_TIMEOUT = 10  # Authentication timeout

# Keep-Alive Settings
# KEEPALIVE_INTERVAL = 30  # Send keepalive every N seconds (0 to disable)

# Compression
# COMPRESS = false  # Enable SSH compression

# Known Hosts File
# KNOWN_HOSTS_FILE = ~/.ssh/known_hosts

# Jump Host / Bastion Configuration (optional)
# PROXY_HOST = bastion.example.com
# PROXY_PORT = 22
# PROXY_USERNAME = bastion_user
# PROXY_PASSWORD = bastion_password
# PROXY_KEY_FILE = /path/to/bastion_key

# SFTP Settings
# SFTP_TIMEOUT = 60  # SFTP operation timeout

[teams]
# Microsoft Teams integration settings
# Uncomment and configure these settings to use the teams module

# Option 1: Incoming Webhook (Simple method - recommended for getting started)
# Create an incoming webhook in your Teams channel:
# 1. Go to your Teams channel
# 2. Click "..." > Connectors
# 3. Search for "Incoming Webhook" and configure
# 4. Copy the webhook URL

# WEBHOOK_URL = https://your-org.webhook.office.com/webhookb2/xxx-xxx-xxx/IncomingWebhook/xxx/xxx

# Option 2: App-Based Authentication (Advanced - full API access)
# Register an Azure AD app and grant permissions:
# 1. Register app in Azure Portal
# 2. Grant "ChannelMessage.Send" permission
# 3. Create client secret
# 4. Note the tenant, client ID, and secret

# TENANT_ID = xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
# CLIENT_ID = xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
# CLIENT_SECRET = your-client-secret-here
# TEAM_ID = xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
# CHANNEL_ID = 19:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx@thread.tacv2

# Connection Settings
# TIMEOUT = 30  # Request timeout in seconds
# MAX_RETRIES = 3  # Maximum number of retry attempts
# RETRY_BACKOFF = 1.0  # Backoff factor for retries

# Proxy Settings (optional)
# PROXY = http://proxy.example.com:8080

# Notes:
# - Webhook method is simpler but has limited features
# - App-based auth allows full control and additional features
# - Use webhook for basic notifications, app auth for complex integrations
# - Team ID and Channel ID can be found in Teams URL when you navigate to the channel

[slack]
# Slack integration settings
# Uncomment and configure these settings to use the slack module

# Option 1: Incoming Webhook (Simple method - recommended for getting started)
# Create an incoming webhook in your Slack workspace:
# 1. Go to https://api.slack.com/messaging/webhooks
# 2. Click "Create your Slack app"
# 3. Choose "From scratch", name your app, select workspace
# 4. Go to "Incoming Webhooks" and activate it
# 5. Click "Add New Webhook to Workspace"
# 6. Select a channel and authorize
# 7. Copy the webhook URL

# WEBHOOK_URL = https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXX

# Option 2: Bot Token (Advanced - full API access)
# Create a Slack app with bot token:
# 1. Go to https://api.slack.com/apps
# 2. Create new app or select existing
# 3. Go to "OAuth & Permissions"
# 4. Add bot token scopes: chat:write, files:write, reactions:write, etc.
# 5. Install app to workspace
# 6. Copy Bot User OAuth Token (starts with xoxb-)

# BOT_TOKEN = xoxb-your-bot-token-here
# DEFAULT_CHANNEL = #general

# Connection Settings
# TIMEOUT = 30  # Request timeout in seconds
# MAX_RETRIES = 3  # Maximum number of retry attempts
# RETRY_BACKOFF = 1.0  # Backoff factor for retries

# Proxy Settings (optional)
# PROXY = http://proxy.example.com:8080

# Notes:
# - Webhook method is simpler but has limited features (no file uploads, reactions, etc.)
# - Bot token allows full control: upload files, update/delete messages, add reactions
# - Use webhook for basic notifications, bot token for complex integrations
# - Bot token requires OAuth scopes based on features used
# - Channel names should include # for public channels (e.g., #general)
# - For direct messages, use @username or user ID

[clickhouse]
# ClickHouse high-performance analytics database settings
# Uncomment and configure these settings to use the clickhouse module

# Connection Settings
# HOST = localhost
# PORT = 8123  # HTTP interface port (default)
# DATABASE = default

# Authentication
# USERNAME = default
# PASSWORD =

# SSL/TLS Settings (optional)
# USE_SSL = false  # Use HTTPS instead of HTTP
# VERIFY_SSL = true  # Verify SSL certificates

# Performance Settings
# TIMEOUT = 30  # Request timeout in seconds
# COMPRESSION = lz4  # Enable compression: lz4, zstd, or leave empty for none

# Notes:
# - ClickHouse is a column-oriented database for OLAP (Online Analytical Processing)
# - Best for: Analytics, time-series data, log aggregation, data warehousing
# - Supports: Distributed queries, materialized views, partitioning, real-time ingestion
# - Use compression (lz4 or zstd) for better network performance
# - Default HTTP port is 8123, native protocol port is 9000
# - For production, always use authentication and SSL/TLS

[neo4j]
# Neo4j graph database settings
# Uncomment and configure these settings to use the neo4j module

# Connection Settings
# URI = bolt://localhost:7687  # Bolt protocol (default)
# URI = neo4j://localhost:7687  # Neo4j protocol (with routing)
# DATABASE = neo4j

# Authentication
# USERNAME = neo4j
# PASSWORD = password

# SSL/TLS Settings (optional)
# ENCRYPTED = false  # Use encrypted connection
# TRUST = TRUST_ALL_CERTIFICATES  # Certificate trust strategy

# Connection Pool Settings
# MAX_CONNECTION_LIFETIME = 3600  # Max connection lifetime in seconds
# MAX_CONNECTION_POOL_SIZE = 50   # Maximum connections in pool
# CONNECTION_ACQUISITION_TIMEOUT = 60  # Timeout for acquiring connection

# Notes:
# - Neo4j is a native graph database for highly connected data
# - Best for: Social networks, recommendation engines, fraud detection, knowledge graphs
# - Uses Cypher query language (similar to SQL but for graphs)
# - Supports ACID transactions and complex relationship queries
# - Default bolt port is 7687, HTTP port is 7474 (browser interface)
# - For production, always use authentication and consider encryption

[elasticsearch]
# Elasticsearch distributed search and analytics engine settings
# Uncomment and configure these settings to use the elasticsearch module

# Connection Settings
# HOSTS = http://localhost:9200  # Single host
# HOSTS = http://host1:9200,http://host2:9200  # Multiple hosts (comma-separated)

# Authentication (choose one method)
# Option 1: Username/Password
# USERNAME = elastic
# PASSWORD = changeme

# Option 2: API Key (recommended for production)
# API_KEY = base64_encoded_api_key

# SSL/TLS Settings (optional)
# VERIFY_CERTS = true  # Verify SSL certificates
# CA_CERTS = /path/to/ca.pem  # Path to CA certificate bundle

# Connection Settings
# TIMEOUT = 30  # Request timeout in seconds
# MAX_RETRIES = 3  # Maximum number of retry attempts
# RETRY_ON_TIMEOUT = true  # Retry on timeout errors

# Notes:
# - Elasticsearch is a distributed search and analytics engine
# - Best for: Full-text search, log analytics, real-time data, application search
# - Supports: Query DSL, aggregations, full-text search, geospatial queries
# - Can store and analyze massive amounts of data in near real-time
# - Default HTTP port is 9200, transport port is 9300
# - For production, use API keys instead of username/password
# - Always use SSL/TLS in production environments

[timescaledb]
# TimescaleDB time-series database settings (PostgreSQL extension)
# Uncomment and configure these settings to use the timescaledb module

# Connection Settings
# HOST = localhost
# PORT = 5432
# DATABASE = tsdb
# USERNAME = postgres
# PASSWORD = password

# Connection Pool Settings
# POOL_SIZE = 5
# MAX_OVERFLOW = 10

# Notes:
# - TimescaleDB is a PostgreSQL extension optimized for time-series data
# - Best for: IoT data, monitoring metrics, financial data, sensor data, logs
# - Features: Hypertables (automatic partitioning), continuous aggregates, compression
# - Supports: Data retention policies, gap filling, time-bucket queries
# - 100% PostgreSQL compatible - all PostgreSQL features work
# - Automatic chunk management for efficient time-series storage
# - Compression can reduce storage by 90%+
# - Perfect for: High-ingest rates (millions of rows/sec), complex queries on time-series data
